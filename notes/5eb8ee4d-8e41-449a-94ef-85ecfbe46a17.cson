createdAt: "2019-12-23T06:56:21.711Z"
updatedAt: "2019-12-31T08:31:28.432Z"
type: "MARKDOWN_NOTE"
folder: "336e9e5fe19723f750cb"
title: "tips"
tags: []
content: '''
  # tips
  ## unlikely， likely
  使用unlikely好likely不会影响程序执行的效果，但会影响执行的效率。以下逻辑可以通过改写方式来使得执行效率更高
  ```c
  if (error) {
    /*...*/
  }
  
  //我们认为大多数时间都会是error == 0
  if (unlikely(error)) {
    /*...*/
  }
  
  //我们认为大多数时间都会是success == 1
  if (likely(success)) {
    /*...*/
  }
  ```
  ## 内核报错oops和panic
  oops比较轻，panic比较严重，会导致死机。
  
  ## 进程
  - 内核调度的对象是线程，而不是进程，传统的unix中一个进程只包含一个线程。而现在一个进程包含多个线程。linux对线程不过特别区分，线程只是特殊的进程罢了。
  - 进程提供两种虚拟机制，一个是虚拟处理器，另一个是虚拟内存。
    - 虚拟处理器给进程一种假象，自己独享处理器。
    - 虚拟内存给进程一种假象，自己独享所有内存资源。
  - 进程在创建时开始存活，通常调用fork来复制一个现有的进程。fork系统调用返回两次，一次回到父进程（返回子进程pid）一次回到子进程（返回0），一般在fork之后会执行exec函数簇，实际上fork都是有clone系统调用实现的。
  - 进程通过exit系统调用退出执行。进程结束后，会将占用的资源释放掉。父进程可以通过wait系统调用来查子进程是否终结。
  - 进程描述符及任务结构
  任务列表（task list）双向循环链表，链表中的每一项都是task_struct（进程描述符）该结构体描述了进程的所有信息：打开的文件，进程的地址空间，挂起的信号，进程的状态，等等。
    - 分配进程描述符
      - 通过slab分配器。
    - 进程描述符的存放
      - 内核通过唯一的进程描述符pid来表示每个进程。pid_t类型（int 类型）
      - 内核中，要访问任务通常都是通过获得指向task_struct的指针，通过current宏找到正在运行的进程描述符，硬件不同，实现该宏的方式也不同。
    - 进程状态
      - TASK_RUNNING
        - 进程可执行（在等待队列中），或者正在执行。这是进程在用户空间执行的唯一可能状态。这种状态也可以应用到内核空间正在执行的进程。
      - TASK_INTERRUPTIBLE
        - 进程正在睡眠（被阻塞），等待某些条件达成，一旦条件达成内核则会把进程状态设置为TASK_RUNNING
      - TASK_UNINTERRUPIBLE
        - 除了就收到信号也不会被唤醒或者投入运行之外，其他与TASK_INTERRUPTIBLE相同，使用的很少。
      - __TASK_TRACED
        - 被其他进程跟踪的进程，例如ptrace
      - __TASK_STOPPED
        - 进程停止执行，通常这种状态发生在接收到SIGSTOP,SIGSTP,SIGTTIN,SIGTTOU等信号
    - 设置当前进程状态
      - set_task_state(task, state);
      - 
    - 进程上下文
      - 代码从一个可执行文件载入到进程的地址空间执行，一般程序在用户空间执行。当一个程序调用了系统调用或者触发了某个异常，它就会陷入内核空间。此时我们称内核代表进程在执行，并处在进程上下文中。current宏是有效的。
    - 进程家族树
      - 进程之间都有明显的继承关系。所有进程都是pid为1的init进程的后代。内核在系统启动的最后阶段启动init进程。该进程读取系统的初始化脚本并执行相关其他进程。【0进程（idle进程）是系统创建的第一个进程，也是唯一一个没有通过fork或者kernel_thread产生的进程。完成系统加载后，演变为进程调度和交换，1进程（init进程）由0进程通过kernel_thread创建，完成系统的初始化，是系统中所有其他进程的祖先，linux中所有的进程都是由init进程创建并运行的，linux内核启动，然后在用户空间启动init进程，再启动其他系统进程。】
      - 有同一个父进程的所有进程成为兄弟进程。
      - 每个task_struct都包含有一个指向父进程的task_struct叫做parent指针。还包含一个成为children的子进程链表。
    - 进程创建
      - fork()通过拷贝当前进程创建一个子进程。子进程与父进程的区别仅仅在于pid和ppid（子进程将其设置为被拷贝进程的pid）和某些资源和统计量（一些资源统计量没有必要复制，比如挂起的信号）。exec()负责将可执行文件读取并将其载入地址孔家你开始运行。  
      - 写时拷贝，只有在需要写入的时候才去拷贝，从而使各个进程拥有自己的拷贝。资源的拷贝只有在需要写入时才进行。
      - linux通过clone实现fork，其中fork，vfork，__clone库函数都是通过各自的需求参数去调用clone去do_fork.
      - do_fork流程
        1. 调用dup_task_struct()为新锦成穿件一个内核栈，thread_info结构体和task_struct只写值与父进程相同。
        2. 价差并确保新创建这个子进程后，当前用户所拥有的所有进程数目没有超出给他分配的资源的限制。 
        3. 子进程着手与父进程区分开，（进程描述符成员都要设为初始值，主要是统计信息，大多数依旧没有被修改）。
        4. 子进程设置为TASK_INTERRUBPTIBLE，保证暂时不会投入运行。
        5. copy_process调用copy_flags()以更新task_struct，表明进程是否有超级用户权限的PF_SUPERPRIV标志被清0.表明进程还没有调用exec()函数的PF_FORKNOEXEC标志被设置。
        6. 调用alloc_pid为新进程分配一个有效的pid
        7. 根据传递给clone()参数标志，copy_process()拷贝活共享打开的文件、文件系统信息、信号处理函数、进程地址空间和命名空间。
        8. 最后，copy_process()做扫尾工作并返回一个指向子进程的指针。
      - 一般内核有意有限选择子进程执行。因为一般子进程都会马上调用exec()函数，这样可以避免写实拷贝的额外开销。如果父进程首先执行，有可能会开始向地址空间写入。
    - 线程在linux中的实现
      - 线程只是被视为一个与其他进程共享某些自愿的进程，每个线程都拥有唯一隶属于自己的task_struct，在内核中它看起来像是一个普通进程。  
      - 线程的创建和普通进程类似。只是在调用clone()的时候需要传递一些参数标志来指明需要的共享资源。
      clone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, 0);
      上面的代码产生的结果和调用fork()差不多，只是父子俩共享地址空间，文件系统资源，文件描述符和信号处理程序。
      普通fork的实现：
      clone(SIGCHILD, 0);
      ![新建位图图像 (6).bmp](:storage\\5eb8ee4d-8e41-449a-94ef-85ecfbe46a17\\3092340d.bmp)
      ![新建位图图像 (7).bmp](:storage\\5eb8ee4d-8e41-449a-94ef-85ecfbe46a17\\79c4a6b9.bmp)
      - 内核线程
      内核线程和普通的进程间的区别在于内核线程没有独立的地址空间（实际上指向地址空间的mm指针被设置为NULL），只运行在内核空间，不会切换到用户空间去。内核和普通进程一样可以被调度，可以被抢占。
      kthread_create，kthread_run。内核线程启动后一直运行到do_exit后停止，或者在其他地方调用kthread_stop
      - 进程终结
      大多数任务是靠do_exit来终结，主要做以下繁琐的工作
        - exit_notify()给父进程发送信号进程变成EXIT_ZOMBIE.
        - 释放资源，do_exit()调用schedule()切换到新进程。
        - 处于EXIT_ZOMBIE的进程不会被调度，所占有的所有内存就是内核栈，thread_info和task_struct，此时进程存在的唯一目的就是向父进程提供信息。父进程检索到信息后，获得那是无关信息后，由进程所持有的内存被释放。
        - wait()这一簇函数都是通过唯一的一个系统调用wait4()来实现，标准动作是挂起调用它的进程，直到其中的一个子进程退出。release_task()调用put_task_struct()释放进程内核栈和thread_info结构所占的页，并释放task_struct所占的slab高速缓存。
      - 用户抢占
      内核即将放回用户空间的时候，如果当前进程need_reched标志被设置，会导致schedule被调用，此时会发生用户抢占。在内核返回用户空间的时候，它知道自己是安全的，因为既然它可以继续去执行当前进程，那么它当然可以再去选择一个新的进程去执行。内核无论是在中断处理程序还是在系统调用后返回，都会检查need_resched标志。如果他被设置了那么内核会选择一个其他（更合适的）进程投入运行。
      - 内核抢占
      用户程序再执行系统调用期间可以被抢占（用户进程陷入到内核态时），该进程被暂时挂起。 
      1. 在中断处理程序中不允许内核抢占。中断返回再执行内核抢占
      2. 当内核执行软中断或tasklet时，禁止内核抢占，中断返回时再执行内核抢占。
    ## 系统调用
    
    ## 内存管理
    
    ### 页
      - 内核把物理页作为内存管理基本单位，内存管理单元（MMU）通常以页为单位进行处理。从虚拟内存的角度来看，页就是最小单位。
      - 内核用struct page结构体表示系统的每一个*物理页*
      ```c
        struct page {
          unsigned long flags;
          atomic_t _count;
          atomic_t _mapcount;
          unsigned long private;
          struct address_space *mapping;
          pgoff_t index;
          struct list_head lru;
          void *virtual;
        }
      ```
      - flag域来存放页的状态，这些状态包括页是不是脏的，是不是锁定在内存中等。
      - _count域指定存放页的引用计数。当计数值为-1时，就说明当前内核并没有引用这一页，在新的分配中可以使用它
      - virtual域是页的虚拟地址。通常情况下，它就是也在虚拟内存的位置。有些内存并不是永久的映射到内核地址空间上，在这种情况下，这个域的值为NULL，需要的时候必须动态的映射这些页。
      - struct page结构体和物理页相关，并非和虚拟页相关。因此该结构对页的描述只是短暂的。即使页中所包含的数据继续存在，由于交换等原因，他们也可能不在和page结构相关联。内核仅仅用这个数据结构来描述当前时刻在相关物理页存放的东西。
      - 内核用page这个结构体来管理所有的物理页，因为内核需要知道一个页是否空闲，如果也已经被分配，内核还需要知道谁拥有这个页，拥有者可能是用户空间进程，静态内核代码，页高速缓存。
      - 每一个物理页都要有这样一个结构体与之对应。
        
    ### 区  
       - 由于硬件的限制，内核并不能对所有的页都一视同仁。有些页位于特定的物理地址上，所以不能将其用于一些特定的任务。
          1.一些硬件稚嫩用某些特定的内存地址进行DMA。
          2.一些体系结构的内存物理寻址范围比虚拟地址大的多，这样就有一些内存不能永久的映射到内核空间上。
       - linux 主要有四种区：
       1. ZONE_DMA----这个区域包含的页能进行DMA操作
       2. ZONE_DMA32----与ZONE——DMA类似，不同之处在于，这些页只能被32位设备访问，在某些体系结构中该区比ZONE_DMA更大
       3. ZONE_NORMAL----这个区包含的都是能正常映射的页
       4. ZONE_HIGHMEM----这个区包含“高端内存”，其中的页并不能永久的映射在内核地址空间。
       - 区的使用和体系结构有关。例如有些区在所有内存地址上都可以执行DMA操作。在x86体系机构上，ISA设备就不能在整个32位地址空间执行DMA。
       - ZONE_HIGHMEM的工作方式也差不多。能否直接映射取决于体系结构。在32位x86系统上，ZONE_HIGHMEM为高于896M的所有物理内存。在其他体系机构上所有内存都被直接映射，所以ZONE_HIGHMEM为空。
       - ZONE_HIGHMEM为所谓的高端内存，系统的其余区域为所谓的低端内存。除去ZONE_DMA和ZONE_HIGH之后剩下的就是ZONE_NORMAL
       - x86体系结构ZONE_NORMAL从16M到896M，在其他体系结构上，ZONE_NORMAL是所有可用的物理内存。
       - 区的划分没有任何物理意义，不过是内核为了管理叶而采取的一种逻辑上的分组。
     ### 获得页
       - 内核提供了一种请求内存的底层机制。
       - 核心函数
       ```c
       struct page *alloc_pages(gfp_t gfp_mask, unsigned int order)
       ```
       该函数分配2^order个连续物理页，并返回一个只想第一个页的page结构体的指针。
       ```c
       void *page_address(struct page *page);
       ```
       该函数返回一个指针，指向给定页的逻辑地址
       
       ```c
       unsigned long __get_free_pages(gfp_t gfp_mask, unsigned int order)
       ```
       该函数与alloc_pages相同，不过它直接返回一个页的逻辑地址。因为页是连续的，所以其他页也会紧随其后。
       - 获得填充为0的页
       ```c
       unsigned long get_zeroed_page(unsigned int gfp_mask)
       ```
       该函数与__get_free_pages()工作方式相同，只不过把分配好的页都填充了0，虽说分配好的页中应该包含的都是随机产生的垃圾信息，但其实这些信息可能并不是完全随机的，有可能包含敏感信息，在返回到用户空间需要清0.
       - 释放页
       释放页是要谨慎，只能释放自己的页，否则系统会崩。
       ```c
       void __free_pages(struct page *page, unsigned in order);
       void free_pages(unsigned long addr, unsigned in order);
       void free_page(unsigned long addr);
       ```
       调用__get_free_pages（GFP_KERNEL, 3）之后要注意错误检查，内核分配可能失败。因此你的代码必须进行检查并做相应处理。这意味着再此之前，你所做的所有工作可能前功尽弃。因此代码尽量在一开始就申请内存。
       - kmalloc
       - 分配物理空间连续的内存给内核。
       - 分配内存的选项在不同情况下使用不同的选项。
       ![新建位图图像 (8).bmp](:storage\\5eb8ee4d-8e41-449a-94ef-85ecfbe46a17\\315e2df8.bmp)
       ![新建位图图像 (9).bmp](:storage\\5eb8ee4d-8e41-449a-94ef-85ecfbe46a17\\31db0f51.bmp)
       - kfree
       用来释放kmalloc的内存
       - vmalloc
       工作方式类似于kmalloc，只不过前者分配的内存虚拟地址是联系的，而物理地址则无需连续。这也是用户空间分配函数的工作方式。由malloc返回的页在进程的虚拟空间内是连续的，但是不能保证物理RAM是连续的。它通过分配非连续的内存块，再“修正”页表，把内存映射到逻辑地址空间的连续区域中。
       一般情况下，硬件需求物理地址是连续的，但是一般内核代码都用kmalloc来获取内存，而不是vmalloc主要是考虑到性能。vmalloc()函数为了把物理不连续的页转换为虚拟地址上的连续的页，必须专门建立页表项，糟糕的是，通过vmalloc获得的页必须一个一个的进行映射（因为物理上不连续），这就会导致比直接内存映射大的多的tlb的抖动，因此只有在获得很大块内存的时候用vmalloc来获得内存。
       - vfree
       通过vmalloc创建的内存区域通过vfree来收回。
       - slab层
         - 为了便利分配和释放数据结构，编程人员会用到空闲链表，空闲链表包含可供使用的已经分配好的数据块。当代码需要一个新的数据结构实例时，可以从空闲链表中抓取一个，而不需要分配内存再把内存放进去。空闲链表相当于对象告诉缓存。空闲链表无法全局掌控，内核无法通知每个空闲链表，让其收缩缓存的大小以便放出一些内存。为了代码更加坚固，linux内核提供了slab层。
         - slab分配器试图在几个进本原则之间寻求一种平衡：
         1. 频繁使用的数据结构也会频繁分配和释放
         2. 频繁分配和回收必然会导致内存碎片
         3. 回收的对象可以立即投入下一次分配
         - kmalloc建立在slab层之上，使用了一组通用高速缓存。
         - 高速缓存又被划分为slabslab由一个或者多个物理上连续的页构成，一般slab是有一页组成，每个高速缓存可以有多个slab组成。
         - 每个slab包含一些对象成员。对象是指被缓存的数据结构。每个slab处于三种状态之一：满、部分满和空。
  ![新建位图图像 (10).bmp](:storage\\5eb8ee4d-8e41-449a-94ef-85ecfbe46a17\\2e35292e.bmp)
          - 每个高速缓存窦世勇kmem_cache结构来表示。这个结构包含三个链表：slabs_full, slabs_partial, slabs_empty，均在kmem_list3结构内，该结构在mm/slab.c中定义。这些链表包含高速缓存中的所有slab。slab描述符struct slab用来描述每个slab
          - 所谓着色, 就是把不同对象地址, 以缓存行对单元错开, 从而使不同对象占用不同的缓存行，从而提高缓存的利用率并获得更好的性能。
  
  ```c
  struct slab {
    struct list_head list;/*满，部分满或空链表*/
    unsigned long colouroff;/*slab着色的偏移量*/
    void *s_mem;/*slab中已分配的对象数*/
    unsigned int inuse;/*slab中已分配的对象数*/
    kmem_bufctl_t free;/*第一个空闲对象（如果有的话）*/
  }
  ```  
          - slab分配器可以创建新的slab，通过__get_free_pages()低级内核页分配进行。
          - 高速缓存结构体通过以下函数创建
  ```c
  struct kmem_cache *kmem_cache_create(const char *name, size_t size, size_t align, unsigned long flags, void (*ctor)(void *));
  ```
          - 撤销高速缓存。不能在中断上下文中调用这个函数，因为它可能睡眠。调用该函数之前必须确保（1）高速缓存中slab必须都是空（2）调用kmem_cache_destroy过程中和后不能再访问这个高速缓存。
  ```c
  int kmem_cache_destroy(struct kmem_cache *cachep);
  ```
          - 从缓存中分配
          创建高速缓存之后，可以通过下列函数获取对象。
  ```c
  void *kmem_cache_alloc(struct kmem_cache *cachep, gfp_t flags);
  ```
          该函数从指定的高速缓存cachep中返回一个指向对象的指针。如果高速缓存的所有slab中没有空闲的对象，那么slab层必须通过kmem_getpages()获取新的页。
  
  ```c
  void kmem_cache_free(struct kmem_cache *cachep, void *objp);
  ```
          该函数能把cachep中对象objp标记为空闲。
      
      - 在栈上静态分配
      用户空间有很大的栈，但内核栈小而固定。每个进程的内核栈大小既依赖体系结构，也与编译时的选项有关。历史上，每个进程都有两个页的内核栈。历史上，中断处理程序和被中断进程共享一个栈。当一页栈选项激活时，中断处理程序获得了自己的栈。在函数中不要定义超过几百字节的变量。当栈溢出时，会覆盖掉紧邻堆栈末端的东西。当栈溢出时，最好的情况是宕机，最坏的情况是悄无声息的破坏数据。因此，进行动态分配是一种明智的选择。
      - 高端内存的映射
      高端内存的页不能永久的应设在内核地址空间上。因此用alloc_pages()函数以__GFP_HIGHMEM标志获得的页不可能有逻辑地址。
        - 永久映射
        映射一个给定的page结构到内核地址空间
        ```c
        void *kmap(struct page *page);
        void kunmap(struct page *page);
        ```
        该函数在高端内存或者低端内存上都能用。如果page对应的是低端内存的一页，函数只会单纯的返回该页的虚拟地址。如果页位于高端内存，则会建立一个永久映射，再返回地址。这个函数可以睡眠，因此kmap()只能用在进程上下文中。
    ### 页高速缓存和页回写
      - 页高速缓存是linux内核实现磁盘缓存，主要用来减少磁盘的I/O操作。要注意和slab中的高速缓存作区分。
      - 三种策略：1. nowrite 2. write-through 3. write-back
    ### 调试
    - 在任何时候，任何地方都可以用printk来打印。
    - 注意编译内核时的配置选项，CONFIG_DEBUG_KERNEL选项，slab layer debugging、high-memory debugging、I/O mapping debugging、spin-lock debugging、stack-overflow checking。
    - 内核提供了一个原子操作计数器。它可以被配置成一个一旦在原子操作过程中进入了睡眠或者做了一些可能引起睡眠的操作，就打印警告信息。包括正使用锁的时候调用schedule()。正在使用锁的时候以阻塞的方式请求分配内存和在引用单cpu数据时睡眠在内。CONFIG_PREEMPT=Y CONFIG_DEBUG_KERNEL=Y CONFIG_KALLSYMS=Y CONFIG_DEBUG_SPINLOCK_SLEEP=Y
    - 引发bug并打印信息
    1. 一些内核调用可以用来方便标记bug，提供断言并输出信息。最常用的两个是BUG()和BUG_ON()。当被调用的时候会引发oops，导致栈的回溯和错误信息打印。这些声明会导致oops跟硬件的体系结构有关。大部分体系结构会将其定义为非法操作。如下使用：
    ```c
    if(bad_thing)
      BUG();
    或者
    BUG_ON(bad_thing);
    ```
    2. 也可以用panic引发更严重的错误。调用panic不但会但因错误消息，而且还会挂起整个系统。
    ```c
    panic("terrible thing is %ld\\n", terrible_thing);
    ```
    3. 有些时候可以在中断上打印一下栈的回溯信息来帮助调试。这个时候，dump_stack()就很有用了。
    ```c
    if(!debug_check)
    {
      printk(KERN_DEBUG "provide some information...\\n");
      dump_stack();
    }
    ```
      ### 进程地址空间
        
  
'''
linesHighlighted: []
isStarred: false
isTrashed: false
